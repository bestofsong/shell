#!/usr/bin/env bash

set -e

declare -a trees
trees=("$@")

# 通过echo向stdio输出的代码，这些生成的代码的功能是：执行时在当前目录完整恢复传入的多个目录的文件
pack_file() {
  # 文件路径
  local file=$1
  # 从tree文件夹开始的相对路径
  local file_relative=$2
  local dir_relative
  dir_relative=$(dirname "$file_relative")
  # 自定义EOF避免和文件内部的冲突
  local file_delim
  file_delim="shellpack-${RANDOM}"
  while grep "$file_delim" "$file" >/dev/null ; do
    file_delim="shellpack-${RANDOM}"
  done
  # 设置执行权限
  local perm
  perm=$(stat -f '%Lp' "$file")
  # mkdir
  echo "# Generate file: $file_relative"
  echo 'mkdir -p "'"$dir_relative"'"'
  echo 'cat >'"$file_relative"' <<"'"$file_delim"'"'
  cat "$file"
  echo $file_delim
  echo 'chmod '"$perm"' "'"$file_relative"'"'
  echo '#================================='
  echo
}

echo '#!/usr/bin/env bash'
echo

cat <<"EOF"
is_install=false
while [ "$#" -gt 0 ] ; do
  key="$1"
  case $key in
      --install)
      is_install=true
      shift
      ;;
      --default)
      shift
      ;;
      *)
  esac
done


EOF

re_source_filename_exclude='.+\.swp|\.tags|\.DS_Store|.+\.part'
for tree in "${trees[@]}"; do
  full_tree_path=`(cd "${tree}" && pwd)`
  tree_name=$(basename "$tree")
  files=($(find -E "${full_tree_path%%/}" \
    -type f -and -not -iregex "$re_source_filename_exclude" ))
  for file in "${files[@]}"; do
    relative_file_path=${file#$full_tree_path}
    relative_file_path="${tree_name}$relative_file_path"
    pack_file "$file" "$relative_file_path"
  done
done

cat <<"EOF"
cwd=$(pwd)
echo 'export SHELLPACK_HOME="'"$cwd"'"' >shellpack.conf

if $is_install ; then
  exit
fi

EOF

# 下面生成的代码的功能：在当前目录生成一个加载上面说的恢复目录的脚本shellpack_loader.sh
# 并把. shellpack_loader.sh <trees>这样的一条语句插入用户的profile文件里
# 导出tree列表给下面生成的代码使用
export_tree_list_stmt='tree_list=('
for tree in "${trees[@]}" ; do
  export_tree_list_stmt+='"'$(basename "$tree")'"'
  export_tree_list_stmt+=' '
done
export_tree_list_stmt+=')'
echo "$export_tree_list_stmt"

cat <<"EOF"
declare -a tree_list2
for item in "${tree_list[@]}" ; do
  tree_list2+=("$(pwd)/$item")
done
IFS_=$IFS
IFS=$'\n'
tree_list_str="${tree_list2[*]}"
IFS=$IFS_

cat >shellpack_loader.sh <<EOFEOF
declare -a _shellpack_tree_list
IFS_=\$IFS
IFS=$'\n'
_shellpack_tree_list=($tree_list_str)
IFS=\$IFS_
EOFEOF

EOF

cat <<"EOFEOF"
cwd=$(pwd)

echo '. "'"${cwd}/shellpack.conf"'"' >>"shellpack_loader.sh"

cat >>"shellpack_loader.sh" <<"EOF"

_shellpack_load_functions=()
_shellpack_load_sourced_scripts=()
shellpack_load_summary() {
  echo "===================================="
  echo "shellpack loaded functions:"
  echo "  ${_shellpack_load_functions[*]}"
  echo "------------------------------------"
  echo "shellpack sourced scripts:"
  echo "  ${_shellpack_load_sourced_scripts[*]}"
  echo "===================================="
}

{
  while read -r ff ; do
    func_name=$(basename "$ff" '.sh' | tr ' -' '__')
    # 函数库
    if expr "$ff" : '.*func.sh$' > /dev/null ; then
      _shellpack_load_sourced_scripts+=("$ff")
      . "$ff"
    # 可执行脚本且名称没有被占用
    elif [ -x "$ff" ] && ! type "$func_name" >/dev/null 2>&1 ; then
      _shellpack_load_functions+=("$func_name")
      eval "$func_name"'() { bash "'"${ff}"'" "$@" ; }'" ; export -f $func_name"
    fi
  done
} < <(find "${_shellpack_tree_list[@]}" -type f)
EOF
EOFEOF

cat <<"EOF"
cwd=$(pwd)

shellpack_loader_installed_path=${cwd}/shellpack_loader.sh
source_loader_line=". \"${shellpack_loader_installed_path}\""
if grep -E '^\. "'"${shellpack_loader_installed_path}"'"' "${HOME}/.bashrc" >/dev/null 2>&1 ; then
  sed -i.bak 's;^\. "'"${shellpack_loader_installed_path}"'".*$;'"${source_loader_line};" "${HOME}/.bashrc" \
  && rm "${HOME}/.bashrc.bak"
else
  echo "$source_loader_line" >>"${HOME}/.bashrc"
fi
EOF
