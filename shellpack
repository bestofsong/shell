#!/usr/bin/env bash

set -e

declare -a trees
trees=("$@")

# 通过echo向stdio输出的代码，这些生成的代码的功能是：执行时在当前目录完整恢复传入的多个目录的文件
pack_file() {
  # 文件路径
  local file=$1
  # 从tree文件夹开始的相对路径
  local file_relative=$2
  local dir_relative
  dir_relative=$(dirname "$file_relative")
  # 自定义EOF避免和文件内部的冲突
  local file_delim
  file_delim="shellpack-${RANDOM}"
  while grep "$file_delim" "$file" >/dev/null ; do
    file_delim="shellpack-${RANDOM}"
  done
  # 设置执行权限
  local perm
  perm=$(stat -f '%Lp' "$file")
  # mkdir
  echo "# Generate file: $file_relative"
  echo 'mkdir -p "'"$dir_relative"'"'
  echo 'cat >'"$file_relative"' <<"'"$file_delim"'"'
  cat "$file"
  echo $file_delim
  echo 'chmod '"$perm"' "'"$file_relative"'"'
  echo '#================================='
  echo
}

re_source_filename='.+\.h|.+\.m|.+\.mm|.+\.c|.+\.cc|.+\.cpp|.+\.hpp|.+\.txt|.+\.sh'

echo '#!/usr/bin/env bash'

for tree in "${trees[@]}"; do
  full_tree_path=`(cd "${tree}" && pwd)`
  tree_name=$(basename "$tree")
  files=($(find -E "${full_tree_path%%/}" \
    -type f -and \( -perm +111 -or -iregex "$re_source_filename" \) ))
  for file in "${files[@]}"; do
    relative_file_path=${file#$full_tree_path}
    relative_file_path="${tree_name}$relative_file_path"
    pack_file "$file" "$relative_file_path"
  done
done

# 下面生成的代码的功能：在当前目录生成一个加载上面说的恢复目录的脚本shellpack_loader.sh
# 并把. shellpack_loader.sh <trees>这样的一条语句插入用户的profile文件里
cat <<"EOFEOF"
cat >"shellpack_loader.sh" <<"EOF"
_shellpack_load_functions=()
_shellpack_load_sourced_scripts=()
shellpack_load_summary() {
  echo "===================================="
  echo "shellpack loaded functions:"
  echo "  ${_shellpack_load_functions[*]}"
  echo "shellpack sourced scripts:"
  echo "  ${_shellpack_load_sourced_scripts[*]}"
  echo "===================================="
}

{
  while read -r ff ; do
    func_name=$(basename "$ff" '.sh' | tr ' -' '__')
    # 函数库
    if expr "$ff" : '.*func.sh$' > /dev/null ; then
      _shellpack_load_sourced_scripts+=("$ff")
      . "$ff"
    # 可执行脚本且名称没有被占用
    elif [ -x "$ff" ] && ! type "$func_name" >/dev/null 2>&1 ; then
      _shellpack_load_functions+=("$func_name")
      eval "$func_name"'() { bash "'"${ff}"'" "$@" ; }'
    fi
  done
} < <(find "$@" -type f)
EOF
EOFEOF

# 导出tree列表给下面生成的代码使用
export_tree_list_stmt='tree_list=('
for tree in "${trees[@]}" ; do
  export_tree_list_stmt+='"'$(basename "$tree")'"'
  export_tree_list_stmt+=' '
done
export_tree_list_stmt+=')'
echo "$export_tree_list_stmt"

cat <<"EOF"
cwd=$(pwd)
abs_tree_list=()
for tree in "${tree_list[@]}" ; do
  abs_tree_list+=("\"${cwd}/${tree}\"")
done
shellpack_loader_installed_path=${cwd}/shellpack_loader.sh
source_loader_line=". \"${shellpack_loader_installed_path}\" ${abs_tree_list[*]}"
if grep -E '^\. "'"${shellpack_loader_installed_path}"'"' "${HOME}/.bash_profile" >/dev/null 2>&1 ; then
  sed -i.bak 's;^\(\. "'"${shellpack_loader_installed_path}"'"..*\);'"${source_loader_line};" "${HOME}/.bash_profile"
else
  echo "$source_loader_line" >>"${HOME}/.bash_profile"
fi
EOF
