#!/usr/bin/env bash

set -e

trees=()
replace_from=
replace_to=
while [ "$#" -gt 0 ] ; do
  key="$1"
  case $key in
      --replace-from)
      replace_from=$2
      shift ; shift
      ;;
      --replace-to)
      replace_to=$2
      shift ; shift
      ;;
      *)
      trees+=("$1")
      shift
      ;;
  esac
done

if [ -z "$replace_from" ] && [ -z "$replace_to" ] ; then
  replace_from=KK
  replace_to=KK
fi

if [ -z "$replace_from" ] ; then
  replace_from=$replace_to
fi

pack_file() {
  # 文件路径
  local file=$1
  # 从tree文件夹开始的相对路径
  local file_relative=$2
  local dir_relative
  local name
  local content
  name=$(basename "$file")
  dir_relative=$(dirname "$file_relative")
  # mkdir
  echo "# Generate file: $file_relative"
  echo 'mkdir -p "'"$dir_relative"'"'
  # cat to file
  new_file="${dir_relative}/${name/#$replace_from/$replace_to}"
  echo '{'
  echo '  sed -E '"s/${replace_from}/${replace_to}/g"' >'\"$new_file\"
  echo '} <<"EOF"'
  cat "$file"
  echo 'EOF'
  echo '#================================='
  echo
  echo
}

for tree in "${trees[@]}"; do
  full_tree_path=`(cd "${tree}" && pwd)`
  tree_name=$(basename "$tree")
  files=($(find -E "${full_tree_path%%/}" \
    -iregex '.+\.h|.+\.m|.+\.mm|.+\.c|.+\.cc|.+\.cpp|.+\.hpp' -type f))
  for file in "${files[@]}"; do
    relative_file_path=${file#$full_tree_path}
    relative_file_path="${tree_name}$relative_file_path"
    pack_file "$file" "$relative_file_path"
  done
done
